# -*- coding: utf-8 -*-

from eabc.granulators import Granulator
from eabc.granulators import Granule
from eabc.extras import BSAS
from eabc.extras.BinarySearch import BinarySearch

import numpy as np



class BsasBinarySearch(Granulator):
    
    def __init__(self,DistanceFunction,clusterRepresentative,tStep):
        
        self._distanceFunction = DistanceFunction
        self._representation = clusterRepresentative #An object for evaluate the representative
        
        self.method=BSAS(self._representation,self._distanceFunction,)
        self.tStep = tStep
 
        super(BsasBinarySearch,self).__init__()
        
    def granulate(self,Dataset):
        
        partitions = BinarySearch(Dataset.data,self.method,self.tStep)
        # reprElems = [self._representation(Dataset.data[l == clustersLabels], self._distanceFunction) for l in range(bestK)]
                
        # #Evaluation - Lower is better
        # normalizeCard = [1-(clustersLabels.tolist().count(l)/len(Dataset.data)) 
        #                  if clustersLabels.tolist().count(l)>1 else 1 for l in range(bestK)]
        # normalizeComp = [reprElems[l][1]/(clustersLabels.tolist().count(l)-1) 
        #                  if clustersLabels.tolist().count(l)>1 else 1 for l in range(bestK)]
        
        # for i,repres in enumerate(reprElems):
        #     F = super(BsasBinary,self)._evaluateF(normalizeComp[i],normalizeCard[i])
        #     newGr = Granule(repres[0],self._distanceFunction,F,normalizeCard[i],normalizeComp[i])
        #     super(BsasBinary,self)._addSymbol(newGr)
        
        return partitions 

# class BSAS:

#     def __init__(self,Representative, Dissimilarity, theta = 0.5, Q=100):

#         self.Representative = Representative
#         self.Dissimilarity = Dissimilarity
#         self.theta = theta
#         self.Q = Q

#     def process(self,Dataset):
    
#         isAssigned = [False] * len(Dataset)
#         clusters = []    
        
#         #init
#         representatives = [self.Representative(Dataset[0])]
#         isAssigned[0] = True
#         clusters.append([0])
        
        
#         for i in range(1,len(Dataset)):
            
#             p = Dataset[i]
            
#             patternToRepDis = [self.Dissimilarity(x._representativeElem, p) for x in representatives]
#             nearestClust = np.argmin(patternToRepDis)
            
#             if patternToRepDis[nearestClust] > self.theta and len(representatives)< self.Q:           
#                 representatives.append(self.Representative(p))
                
#                 clusters.append([i])
                
#                 isAssigned[i] = True
                
#         for i in range(len(Dataset)):
            
#             p = Dataset[i]
            
#             if not isAssigned[i]:
                
#                 patternToRepDis = [self.Dissimilarity(x._representativeElem, p) for x in representatives]
#                 nearestClust = np.argmin(patternToRepDis)
#                 clusters[nearestClust].append(i)
                
#                 representatives[nearestClust].evaluate([Dataset[x] for x in clusters[nearestClust]],self.Dissimilarity)            
                
#         return clusters, representatives

# def BinarySearch(dataset, clusteringProcedure,tStep):
#     """ Ensemble of partition with a Recursive Binary search strategy.
#     Input:
#     - tm: lower bound
#     - tM: upper bound
#     - tStep: resolution step at which the search must be stopped.
#     Output:
#     - v: vector returning the binary search values (including upper and lower value). """
    
#     partition = {} # dict.keys = theta - dict.values = [clustersLabels, representatives]
#     #Initialize min
#     clusteringProcedure.theta = 0
# #    partition[0]= [clusteringProcedure.process(dataset)]
#     partition[0]= clusteringProcedure.process(dataset)
#     numClustMin = len(partition[0][1])
    
#     #Initialize max
#     clusteringProcedure.theta = 1
# #    partition[1]= [clusteringProcedure.process(dataset)]
#     partition[1]= clusteringProcedure.process(dataset)
#     numClustMax = len(partition[1][1])
    
#     recursiveBSP(0,1,numClustMin,numClustMax,dataset,tStep,partition,clusteringProcedure)
    
#     return partition
    
# #TODO: Return correct partition only for latest if condition. The clustering procedure
# # tries to perform operations even if there equal partitions 
# def recursiveBSP(tm,tM,NC1,NC2,data,tStep,partitionDict,clusteringProcedure):
            
#     dt = copy.copy(tM - tm)/2
    
#     if (NC1!=NC2
#         and (dt>= tStep)
#         and (tM-(tm+dt)>=tStep)):
        
#         newTheta = dt+tm
#         clusteringProcedure.theta = newTheta
#         res = clusteringProcedure.process(data)
#         numClust = copy.copy(len(res[1]))
        
#         if numClust!=NC1 and numClust!=NC2:        
#             partitionDict[newTheta]=res

#             recursiveBSP(tm,tm+dt,NC1,numClust,data,tStep,partitionDict,clusteringProcedure)
#             recursiveBSP(tm+dt,tM,numClust,NC2,data,tStep,partitionDict,clusteringProcedure)
        
        
    
    
    